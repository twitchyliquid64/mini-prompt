//! Wire-format types to use when driving LLM APIs.

use crate::{FinishReason, Role};
use serde::{Deserialize, Serialize};

/// The serialized format representing the output of a turn in an LLM conversation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OAIChatMessage {
    /// Role: system, user, assistant, tool
    pub role: Role,

    /// Content of the message, optional when using tool calls
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,

    /// The tool calls generated by the model, such as function calls.
    ///
    /// Typically invoked from a model: i.e. role == `assistant`
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub tool_calls: Vec<OAIToolCall>,

    /// Tool call that this message is responding to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_call_id: Option<String>,

    /// Name of the actor, typically set to the responding function if a tool call response
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl OAIChatMessage {
    pub fn user<S: Into<String>>(s: S) -> Self {
        OAIChatMessage {
            role: Role::User,
            content: Some(s.into()),
            tool_calls: vec![],
            tool_call_id: None,
            name: None,
        }
    }
    pub fn assistant<S: Into<String>>(s: S) -> Self {
        OAIChatMessage {
            role: Role::Assistant,
            content: Some(s.into()),
            tool_calls: vec![],
            tool_call_id: None,
            name: None,
        }
    }
    pub fn system<S: Into<String>>(s: S) -> Self {
        OAIChatMessage {
            role: Role::System,
            content: Some(s.into()),
            tool_calls: vec![],
            tool_call_id: None,
            name: None,
        }
    }
    pub fn tool<S: Into<String>>(s: S) -> Self {
        OAIChatMessage {
            role: Role::Tool,
            content: Some(s.into()),
            tool_calls: vec![],
            tool_call_id: None,
            name: None,
        }
    }
}

/// Describes an invocation of some tool.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OAIToolCall {
    /// The ID of the tool call.
    pub id: String,
    /// The type of the tool, must be `function`.
    pub r#type: ToolCallType,
    /// The function that the model called.
    pub function: FunctionCall,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum ToolCallType {
    #[default]
    Function,
}

/// Describes the invocation of some function, typically 1:1 within a [OAIToolCall].
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FunctionCall {
    pub name: String,
    pub arguments: String,
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub(crate) struct OpenrouterProvider {
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub ignore: Vec<String>,
}

/// Describes a tool available in a model call.
#[derive(Clone, Debug, Serialize)]
pub struct OAITool {
    /// Must be `function`
    pub r#type: String,
    pub function: FunctionInfo,
}

impl From<FunctionInfo> for OAITool {
    fn from(fi: FunctionInfo) -> Self {
        Self {
            r#type: "function".into(),
            function: fi,
        }
    }
}

/// Describes the schema of a tool (function call) available for a model to call.
#[derive(Debug, Clone, Serialize)]
pub struct FunctionInfo {
    /// A description of what the function does.
    pub description: String,
    /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
    pub name: Option<String>,
    /// The parameters the functions accepts, described as a JSON Schema object. See the guide for examples, and the JSON Schema reference for documentation about the format.
    /// To describe a function that accepts no parameters, provide the value {"type": "object", "properties": {}}.
    pub parameters: serde_json::Value,
}

impl FunctionInfo {
    pub fn new<S: Into<String>>(
        name: S,
        description: S,
        parameters: Option<serde_json::Value>,
    ) -> Self {
        Self {
            name: Some(name.into()),
            description: description.into(),
            parameters: match parameters {
                Some(p) => p,
                None => serde_json::json!({"type": "object", "properties": {}}),
            },
        }
    }
}

#[derive(Debug, Clone, Serialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum OAIToolChoice {
    #[default]
    None,
    Auto,
}

/// A request to the OpenAI Chat Completions API.
#[derive(Debug, Clone, Serialize)]
pub(crate) struct OAICompletionsRequest {
    /// Model identifier to use. The exact string is different for every model, and often
    /// varies depending on the provider you are using.
    pub model: String,

    /// Openrouter-specific parameter.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<OpenrouterProvider>,

    /// Model input and output
    pub messages: Vec<OAIChatMessage>,

    /// The list of tools the model can use
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub tools: Vec<OAITool>,

    /// Explicitly enables or disables function calling.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_choice: Option<OAIToolChoice>,

    pub temperature: Option<f32>,
}

impl Default for OAICompletionsRequest {
    fn default() -> Self {
        Self {
            model: <crate::models::Gemma27B3 as crate::models::OpenrouterModel>::MODEL_STR
                .to_string(),
            messages: vec![],
            tools: vec![],
            tool_choice: None,
            provider: None,
            temperature: None,
        }
    }
}

/// A response from the OpenAI Completions API.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OAICompletionsResponse {
    /// Unique ID
    #[serde(default)]
    pub id: String,

    /// Object type, always "chat.completion"
    pub object: Option<String>,

    #[serde(default)]
    pub created: Option<u64>,
    #[serde(default)]
    pub model: String,

    /// Array of completion choices
    #[serde(default)]
    pub choices: Vec<ChatChoice>,
}

/// The serialized description of a response from the model.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatChoice {
    /// Index of this choice in the array of choices
    pub index: usize,

    /// The message generated by the model
    pub message: OAIChatMessage,

    /// Reason why the model stopped generating
    pub finish_reason: FinishReason,
}

/// Describes preferences around tool use to Anthropic.
#[derive(Debug, Default, Clone, Serialize)]
pub(crate) struct AnthropicToolChoice {
    pub r#type: OAIToolChoice,
    pub disable_parallel_tool_use: bool,
}

/// A request to the Anthropic messages API.
#[derive(Debug, Default, Clone, Serialize)]
pub(crate) struct AnthropicMsgRequest {
    /// Model identifier to use for completion
    pub model: String,

    /// Model input and output
    pub messages: Vec<AnthropicMessage>,

    /// The system prompt.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub system: Option<String>,

    /// The maximum number of tokens that can be used.
    pub max_tokens: usize,

    /// Explicitly enables or disables function calling.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_choice: Option<AnthropicToolChoice>,

    /// The list of tools the model can use
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub tools: Vec<AnthropicTool>,

    pub temperature: Option<f32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct AnthropicTool {
    /// The name of the tool which can be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
    pub name: Option<String>,
    /// A description of what the tool does.
    pub description: String,

    /// Describes the layout of parameters the function expects.
    ///
    /// E.G:
    /// ```json
    /// {
    ///   "type": "object",
    ///   "properties": {
    ///     "ticker": {
    ///       "type": "string",
    ///       "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
    ///     }
    ///   },
    ///   "required": ["ticker"]
    /// }
    /// ```
    pub input_schema: serde_json::Value,
}

/// A response from the Anthropic Messages API.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct AnthropicMsgResponse {
    /// Unique ID
    #[serde(default)]
    pub id: String,

    /// Object type, always "message"
    pub object: Option<String>,

    /// Conversational role, always "assistant"
    pub role: Option<String>,

    #[serde(default)]
    pub model: String,

    /// Array of model outputs
    #[serde(default)]
    pub content: Vec<AnthropicCompletion>,

    /// The reason the model stopped producing tokens
    pub stop_reason: FinishReason,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub(crate) enum AnthropicCompletion {
    Text {
        text: String,
    },
    ToolUse {
        id: String,
        name: String,
        input: serde_json::Value,
    },
    ToolResult {
        tool_use_id: String,
        content: String,
    },
}

/// The serialized format representing the output of a turn in an LLM conversation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct AnthropicMessage {
    /// Role: user, assistant
    pub role: Role,
    pub content: Vec<AnthropicCompletion>,
}

impl AnthropicMessage {
    pub fn user_text(text: String) -> Self {
        Self {
            role: Role::User,
            content: vec![AnthropicCompletion::Text { text }],
        }
    }
    pub fn assistant_text(text: String) -> Self {
        Self {
            role: Role::Assistant,
            content: vec![AnthropicCompletion::Text { text }],
        }
    }
    pub fn tool_use(id: String, name: String, input: serde_json::Value) -> Self {
        Self {
            role: Role::Assistant,
            content: vec![AnthropicCompletion::ToolUse { id, name, input }],
        }
    }
    pub fn tool_result(id: String, result: String) -> Self {
        Self {
            role: Role::User,
            content: vec![AnthropicCompletion::ToolResult {
                tool_use_id: id,
                content: result,
            }],
        }
    }
}
