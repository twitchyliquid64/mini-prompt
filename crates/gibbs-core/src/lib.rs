use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use std::env;

pub mod parse;

/// References a specific model.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Model {
    Gemma27B3,
    Qwen235B3,
}

impl Model {
    fn all() -> &'static [Model] {
        use Model::*;
        &[Gemma27B3, Qwen235B3]
    }

    pub fn openrouter_str(&self) -> &'static str {
        use Model::*;
        match self {
            Gemma27B3 => &"google/gemma-3-27b-it",
            Qwen235B3 => &"qwen/qwen3-235b-a22b",
        }
    }
}

impl<'a> TryFrom<&'a str> for Model {
    type Error = ();

    fn try_from(s: &'a str) -> Result<Model, Self::Error> {
        for candidate in Model::all().into_iter() {
            if candidate.openrouter_str() == s {
                return Ok(candidate.clone());
            }
        }
        Err(())
    }
}

/// The serialized format representing the output of a turn in an LLM conversation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessage {
    /// Role: system, user, assistant, tool
    pub role: String,

    /// Content of the message, optional when using tool calls
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,
}

impl ChatMessage {
    pub fn user<S: Into<String>>(s: S) -> Self {
        ChatMessage {
            role: "user".into(),
            content: Some(s.into()),
        }
    }
    pub fn system<S: Into<String>>(s: S) -> Self {
        ChatMessage {
            role: "system".into(),
            content: Some(s.into()),
        }
    }
}

/// The serialized description of one response from the model.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct ChatChoice {
    /// Index of this choice in the array of choices
    pub index: usize,

    /// The message generated by the model
    pub message: ChatMessage,

    /// Reason why the model stopped generating
    pub finish_reason: String,
}

/// A request to the OpenAI Chat Completions API.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct CompletionsRequest {
    /// Model identifier to use for completion
    pub model: String,

    /// Model input and output
    pub messages: Vec<ChatMessage>,
}

/// A response from the OpenAI Completions API.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct CompletionsResponse {
    /// Unique ID
    pub id: String,

    /// Object type, always "chat.completion"
    pub object: String,

    pub created: u64,
    pub model: String,

    /// Array of completion choices
    pub choices: Vec<ChatChoice>,
}

/// Returns the WAN IP from which this code is accessing the internet.
pub async fn wan_ip() -> Result<String, Box<dyn std::error::Error>> {
    let resp = reqwest::get("https://httpbin.org/ip")
        .await?
        .json::<HashMap<String, String>>()
        .await?;

    resp.get("origin")
        .cloned()
        .ok_or("Missing 'origin' key".into())
}

/// Makes a very simple, text-in-text-out model call.
pub async fn model_call<S: Into<String>>(
    model: Model,
    prompt: S,
) -> Result<String, Box<dyn std::error::Error>> {
    let client = reqwest::Client::new();
    let res = client
        .post("https://openrouter.ai/api/v1/chat/completions")
        .bearer_auth(env::var("OR_KEY").unwrap())
        .json(&CompletionsRequest {
            model: model.openrouter_str().into(),
            messages: vec![ChatMessage::system(prompt)],
        })
        .send()
        .await?
        .json::<CompletionsResponse>()
        .await?;

    if res.object != "chat.completion" {
        return Err(format!("unexpected object: {}", res.object).into());
    }
    if res.choices.len() == 0 {
        return Err("unexpected: no completion choices returned".into());
    }
    if res.choices[0].finish_reason != "stop" {
        return Err(format!("unexpected finish reason: {}", res.choices[0].finish_reason).into());
    }

    match res.choices.into_iter().next().unwrap().message.content {
        Some(c) => Ok(c),
        None => Err("unexpected: no message content".into()),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn smoke() {}
}
